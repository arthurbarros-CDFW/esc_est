est_escapement
ch=prepped_data$ch,
ch=prepped_data$ch
beta=optim_results$par
ch=prepped_data$ch,
######################################################
#calculate model fit statistics (aic, qaic, qaicc)
######################################################
loglik<-optim_results$value
ch=prepped_data$ch
beta=optim_results$par
cap_X=model_fit$cap_X[[i]]
surv_X=model_fit$surv_X[[i]]
ints=rep(1,ncol(ch))
p_hat<-fill_prob_matrices(ch,beta,
cap_X,
surv_X,ints)$p_hat
p_hat
View(p_hat)
s_hat<-fill_prob_matrices(ch,beta,
cap_X ,
surv_X,ints)$s_hat
s_hat
View(s_hat)
ch=prepped_data$ch
beta=optim_results$par
cap_X=model_fit$cap_X[[i]]
surv_X=model_fit$surv_X[[i]]
ints=as.matrix(prepped_data$intervals)
p_hat<-fill_prob_matrices(ch,beta,
cap_X,
surv_X,ints)$p_hat
s_hat<-fill_prob_matrices(ch,beta,
cap_X ,
surv_X,ints)$s_hat
p_hat
View(p_hat)
ints
p_hat1<-fill_prob_matrices(ch,beta,
cap_X,
surv_X,ints)$p_hat
ch=prepped_data$ch
beta=optim_results$par
cap_X=model_fit$cap_X[[i]]
surv_X=model_fit$surv_X[[i]]
ints=rep(1,ncol(ch))
p_hat2<-fill_prob_matrices(ch,beta,
cap_X,
surv_X,ints)$p_hat
View(p_hat1)
View(p_hat2)
ints
ints
ch=prepped_data$ch
beta=optim_results$par
cap_X=model_fit$cap_X[[i]]
surv_X=model_fit$surv_X[[i]]
ints=as.matrix(prepped_data$intervals)
ints
p_hat1<-fill_prob_matrices(ch,beta,
cap_X,
surv_X,ints)$p_hat
ints2=rep(1,ncol(ch))
p_hat1<-fill_prob_matrices(ch,beta,
cap_X,
surv_X,ints1)$p_hat
ints1=as.matrix(prepped_data$intervals)
ints2=rep(1,ncol(ch))
p_hat1<-fill_prob_matrices(ch,beta,
cap_X,
surv_X,ints1)$p_hat
p_hat2<-fill_prob_matrices(ch,beta,
cap_X,
surv_X,ints2)$p_hat
s_hat1<-fill_prob_matrices(ch,beta,
cap_X ,
surv_X,ints1)$s_hat
s_hat2<-fill_prob_matrices(ch,beta,
cap_X ,
surv_X,ints2)$s_hat
View(s_hat)
View(s_hat1)
View(s_hat2)
View(s_hat2)
View(s_hat1)
View(s_hat2)
View(s_hat1)
#TESTING FOR THE INTERVALS ISSUE
ch=prepped_data$ch
beta=optim_results$par
cap_X=model_fit$cap_X[[i]]
surv_X=model_fit$surv_X[[i]]
ints1=as.matrix(prepped_data$intervals)
ints2=rep(1,ncol(ch))
p_hat1<-fill_prob_matrices(ch,beta,
cap_X,
surv_X,ints1)$p_hat
p_hat2<-fill_prob_matrices(ch,beta,
cap_X,
surv_X,ints2)$p_hat
s_hat1<-fill_prob_matrices(ch,beta,
cap_X ,
surv_X,ints1)$s_hat
s_hat2<-fill_prob_matrices(ch,beta,
cap_X ,
surv_X,ints2)$s_hat
View(s_hat1)
View(s_hat2)
View(p_hat1)
View(p_hat2)
nan=nrow(ch)
ns=ncol(ch)
p_hat<-s_hat<-matrix( 0, nan, ns ) #create empty matrices
for(i in 1:nan){
for(j in 1:ns){ #fill each cell with pro_capsur() function
p_hat[i,j]<-pro_capsur(i,j,ch,beta,
cap_X,
surv_X,ints1)$p.hat
s_hat[i,j]<-pro_capsur(i,j,ch,beta,
cap_X,
surv_X,ints1)$s.hat
}
}
View(s_hat1)
ints
nan=nrow(ch)
ns=ncol(ch)
p=length(beta)
p
#purpose: evaluate probability of capture and survival for each animal i
cap_beta<-beta[1:(p/2)]
surv_beta<-beta[((p/2)+1):p]
zp<-exp(cap_beta[1]*1+cap_beta[2]*cap_X[i,j])
zs<-exp(surv_beta[1]*1+surv_beta[2]*surv_X[i,j])
p.hat<-zp/(1+zp)
s.hat<-zs/(1+zs)
s.hat<-s.hat*ints[j]
s.hat
ints[j]
ints1
ints
s_hat
i=1
j=2
s_hat[i,j]
pro_capsur(i,j,ch,beta,
cap_X,
surv_X,ints)$s.hat
nan=nrow(ch)
ns=ncol(ch)
p=length(beta)
#purpose: evaluate probability of capture and survival for each animal i
cap_beta<-beta[1:(p/2)]
surv_beta<-beta[((p/2)+1):p]
surv_X[i,j]
surv_X
nan=nrow(ch)
ns=ncol(ch)
p=length(beta)
#purpose: evaluate probability of capture and survival for each animal i
cap_beta<-beta[1:(p/2)]
surv_beta<-beta[((p/2)+1):p]
zp<-exp(cap_beta[1]*1+cap_beta[2]*cap_X[i,j])
zs<-exp(surv_beta[1]*1+surv_beta[2]*surv_X[i,j])
p.hat<-zp/(1+zp)
s.hat<-zs/(1+zs)
s.hat
ints[j]
s.hat**ints[j]
ints[j]
s.hat
s.hat**ints[j]
##########################################
#pro_capsur
##########################################
pro_capsur<-function(i,j,ch, beta,cap_X,surv_X,ints){
nan=nrow(ch)
ns=ncol(ch)
p=length(beta)
#purpose: evaluate probability of capture and survival for each animal i
cap_beta<-beta[1:(p/2)]
surv_beta<-beta[((p/2)+1):p]
zp<-exp(cap_beta[1]*1+cap_beta[2]*cap_X[i,j])
zs<-exp(surv_beta[1]*1+surv_beta[2]*surv_X[i,j])
p.hat<-zp/(1+zp)
s.hat<-zs/(1+zs)
s.hat<-s.hat**ints[j]
est_list<-list('p.hat'=p.hat,'s.hat'=s.hat)
return(est_list)
}
##########################################
#Total escapement
##########################################
total_escapement<-function(ch,beta,cap_X,surv_X,ints){
p_hat<-fill_prob_matrices(ch,beta,
cap_X,
surv_X,ints)$p_hat
s_hat<-fill_prob_matrices(ch,beta,
cap_X ,
surv_X,ints)$s_hat
N_hat=Horvitz_Thompson(p_hat,ch)
Bstar=B_star(ch,s_hat,p_hat)
escapement<-N_hat[[2]]*(log(mean(s_hat[,1]))/(mean(s_hat[,1])-1)) +
sum(Bstar,na.rm=T)
return(ceiling(escapement))
}
total_escapement
est_escapement<-total_escapement(ch=prepped_data$ch,
beta=optim_results$par,
cap_X=model_fit$cap_X[[i]],
surv_X=model_fit$surv_X[[i]],
ints=as.matrix(prepped_data$intervals))
ints
nan=nrow(ch)
ns=ncol(ch)
p=length(beta)
#purpose: evaluate probability of capture and survival for each animal i
cap_beta<-beta[1:(p/2)]
surv_beta<-beta[((p/2)+1):p]
zp<-exp(cap_beta[1]*1+cap_beta[2]*cap_X[i,j])
zs<-exp(surv_beta[1]*1+surv_beta[2]*surv_X[i,j])
p.hat<-zp/(1+zp)
s.hat<-zs/(1+zs)
s.hat<-s.hat**ints[j]
est_list<-list('p.hat'=p.hat,'s.hat'=s.hat)
nan=nrow(ch)
ns=ncol(ch)
p_hat<-s_hat<-matrix( 0, nan, ns ) #create empty matrices
for(i in 1:nan){
for(j in 1:ns){ #fill each cell with pro_capsur() function
p_hat[i,j]<-pro_capsur(i,j,ch,beta,
cap_X,
surv_X,ints)$p.hat
s_hat[i,j]<-pro_capsur(i,j,ch,beta,
cap_X,
surv_X,ints)$s.hat
}
}
p_hat[,1]<-NA
est_list<-list('p_hat'=p_hat,'s_hat'=s_hat)
return(est_list)
p_hat<-fill_prob_matrices(ch,beta,
cap_X,
surv_X,ints)$p_hat
s_hat<-fill_prob_matrices(ch,beta,
cap_X ,
surv_X,ints)$s_hat
N_hat=Horvitz_Thompson(p_hat,ch)
Bstar=B_star(ch,s_hat,p_hat)
escapement<-N_hat[[2]]*(log(mean(s_hat[,1]))/(mean(s_hat[,1])-1)) +
sum(Bstar,na.rm=T)
escapement
ints
#sturgeon testing
library(tidyverse)
library(escapeMR)
library(Rcpp)
sourceCpp('scripts/CJS_functions.cpp')
source("scripts/CVCS_functions.R")
results<-CJS_run()
results
results<-CJS_run()
results<-CJS_run()
write.csv(results,paste("outputs/CJS_results",Sys.Date(),".csv",sep=""))
write.csv(results,paste("outputs/optim_results",Sys.Date(),".csv",sep=""))
results<-CJS_run()
write.csv(results,paste("outputs/optim_results",Sys.Date(),".csv",sep=""))
CJSscript()
#sturgeon testing
library(tidyverse)
library(escapeMR)
library(Rcpp)
sourceCpp('scripts/CJS_functions.cpp')
source("scripts/CVCS_functions.R")
CJSscript()
CJSscript()
CJSscript()
CJSscript()
escapeMR()
CJSscript()
CJSscript()
CJSscript()
CJSscript()
#sturgeon testing
library(tidyverse)
library(escapeMR)
library(Rcpp)
sourceCpp('scripts/CJS_functions.cpp')
source("scripts/CVCS_functions.R")
CJSscript()
CJSscript()
CJSscript()
CJSscript()
CJSscript()
#sturgeon testing
library(tidyverse)
library(escapeMR)
library(Rcpp)
sourceCpp('scripts/CJS_functions.cpp')
#sturgeon testing
library(tidyverse)
library(escapeMR)
library(Rcpp)
sourceCpp('scripts/CJS_functions.cpp')
#sturgeon testing
library(tidyverse)
library(escapeMR)
library(Rcpp)
sourceCpp('scripts/CJS_functions.cpp')
#sturgeon testing
library(tidyverse)
library(escapeMR)
library(Rcpp)
test
sourceCpp('scripts/CJS_functions.cpp')
source("scripts/CVCS_functions.R")
sourceCpp('scripts/CJS_functions.cpp')
install.packages("Rcpp")
install.packages("Rcpp")
sourceCpp('scripts/CJS_functions.cpp')
library(Rcpp)
#sturgeon testing
library(tidyverse)
library(escapeMR)
library(Rcpp)
sourceCpp('scripts/CJS_functions.cpp')
library(rtools43)
library(rtools43)
install.Rtools()
#sturgeon testing
library(tidyverse)
library(escapeMR)
library(Rcpp)
sourceCpp('scripts/CJS_functions.cpp')
#sourceCpp('scripts/CJS_functions.cpp')
source("scripts/CVCS_functions.R")
results<-CJS_run()
results
results<-CJS_run()
results<-CJS_run()
results<-CJS_run()
results<-CJS_run()
results<-CJS_run()
results<-CJS_run()
results<-CJS_run()
results<-CJS_run()
results<-CJS_run()
results<-CJS_run()
results<-CJS_run()
suppressWarnings(rm("ch","chops","covars"))#remove objects
#Part 1: select data prompts
#ask for CH
ch<-read.csv(choose.files(caption="Select your CAPTURE HISTORY data (.csv file)"), head=T, as.is=T)
#ask for chops
chops.ask<-select.list(c(	"YES",
"NO"),
graphics = FALSE,
multiple = FALSE, title = "Do you have CHOPS on 1st Capture data NOT represented as '2' in capture histories?")
if(chops.ask == "YES"){
chops<-read.csv(choose.files(caption="Select your CHOPS data (.csv file)"), head=T, as.is=T)
}
#ask for covars
covars.ask<-select.list(c(	"YES",
"NO"),
graphics = FALSE,
multiple = FALSE, title = "Do you have COVARIATE data?")
if(covars.ask == "YES"){
covars<-read.csv(choose.files(caption="Select your COVARIATE data (.csv file)"), head=T, as.is=T)
} else {
sex <- NULL
length <- NULL
}
#ask for unequal timing
#see Mrawin.f90 (https://github.com/tmcd82070/MRA/blob/master/src/Mrawin.f90)
#line 1270 incorporated in prosur
ints.equal <- select.list(c("YES",
"NO"),
multiple = FALSE,
graphics = FALSE,
title = "Are all intervals between occasions equal?")
if(ints.equal == "NO"){
ints = read.csv(choose.files(caption="Select the file containing lengths of un-equal time intervals (.csv file)"),
head=T, as.is=T)
ints <- ints[,grep("[0-9]",names(ints))]
ints <- unlist(ints)  # must be a vector, not a data frame
# at this point ch may have other columns in it
if( length(ints) != (ncol(ch)-2) ){
stop("Number of time intervals must be 1 less than number of occasions")
}
if( any(ints == 0) ){
stop("Zero time intervals are not allowed.")
}
} else {
ints = rep(1,ncol(ch)-2)
}
#Part 2: prepare ch and covars data
ch=ch[-1] #remove disctag vector from capture histories
null_matrix<-matrix(1,nrow=nrow(ch),ncol=ncol(ch))
if(covars.ask == "YES"){
covars$sex<-as.numeric(ifelse(covars$sex%in%c('F',"f"),1,0)) #change sex to numeric value
covars$length<-as.numeric(covars$length)
}
#Part 3: prep chops data
if(chops.ask == "YES"){
chops<-chops[-1]
clean_chops<-matrix(ncol=ncol(chops))
for(i in 1:ncol(chops)){
d<-chops[i]
r<-rep(0,ncol(chops))
r[i]=2
r<-matrix(rep((r),d),ncol=ncol(chops),byrow=T)
clean_chops<-clean_chops%>%rbind(r)
}
clean_chops<-clean_chops[-1,]
colnames(clean_chops)<-colnames(ch)
}
chops
clean_chops<-matrix(ncol=ncol(chops))
clean_chops
ncol(chops)
for(i in 1:ncol(chops)){
d<-chops[i]
r<-rep(0,ncol(chops))
r[i]=2
r<-matrix(rep((r),d),ncol=ncol(chops),byrow=T)
clean_chops<-clean_chops%>%rbind(r)
}
clean_chops
colnames(clean_chops)<-colnames(ch)
if(chops.ask == "YES"){
chops<-read.csv(choose.files(caption="Select your CHOPS data (.csv file)"), head=T, as.is=T)
}
View(chops)
chops<-chops[-1]
clean_chops<-matrix(ncol=ncol(chops))
View(clean_chops)
for(i in 1:ncol(chops)){
d<-chops[i]
r<-rep(0,ncol(chops))
r[i]=2
r<-matrix(rep((r),d),ncol=ncol(chops),byrow=T)
clean_chops<-clean_chops%>%rbind(r)
}
clean_chops<-clean_chops[-1,]
colnames(ch)
colnames(clean_chops)
colnames(clean_chops)<-colnames(ch)
if(chops.ask == "YES"){
chops<-read.csv(choose.files(caption="Select your CHOPS data (.csv file)"), head=T, as.is=T)
}
chops<-chops[-1]
clean_chops<-matrix(ncol=ncol(chops))
View(clean_chops)
for(i in 1:ncol(chops)){
d<-chops[i]
r<-rep(0,ncol(chops))
r[i]=2
r<-matrix(rep((r),d),ncol=ncol(chops),byrow=T)
clean_chops<-clean_chops%>%rbind(r)
}
clean_chops<-clean_chops[-1,]
colnames(clean_chops)<-colnames(ch)
clean_chops<-as.matrix(clean_chops[-1,])
clean_chops<-matrix(ncol=ncol(chops))
for(i in 1:ncol(chops)){
d<-chops[i]
r<-rep(0,ncol(chops))
r[i]=2
r<-matrix(rep((r),d),ncol=ncol(chops),byrow=T)
clean_chops<-clean_chops%>%rbind(r)
}
View(clean_chops)
clean_chops<-as.matrix(clean_chops[-1,])
clean_chops<-matrix(ncol=ncol(chops))
for(i in 1:ncol(chops)){
d<-chops[i]
r<-rep(0,ncol(chops))
r[i]=2
r<-matrix(rep((r),d),ncol=ncol(chops),byrow=T)
clean_chops<-clean_chops%>%rbind(r)
}
clean_chops<-matrix(clean_chops[-1,])
View(clean_chops)
clean_chops<-(clean_chops[-1,])
clean_chops<-clean_chops[-1, ,drop=FALSE]
clean_chops<-matrix(ncol=ncol(chops))
for(i in 1:ncol(chops)){
d<-chops[i]
r<-rep(0,ncol(chops))
r[i]=2
r<-matrix(rep((r),d),ncol=ncol(chops),byrow=T)
clean_chops<-clean_chops%>%rbind(r)
}
clean_chops<-clean_chops[-1, ,drop=FALSE]
colnames(clean_chops)<-colnames(ch)
#Part 3: prep chops data
if(chops.ask == "YES"){
chops<-chops[-1]
clean_chops<-matrix(ncol=ncol(chops))
for(i in 1:ncol(chops)){
d<-chops[i]
r<-rep(0,ncol(chops))
r[i]=2
r<-matrix(rep((r),d),ncol=ncol(chops),byrow=T)
clean_chops<-clean_chops%>%rbind(r)
}
clean_chops<-clean_chops[-1, ,drop=FALSE]
colnames(clean_chops)<-colnames(ch)
}
#sourceCpp('scripts/CJS_functions.cpp')
source("scripts/CVCS_functions.R")
results<-CJS_run()
