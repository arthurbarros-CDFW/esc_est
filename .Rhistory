starttime<-Sys.time()
{gc()
optim_results<-cpp_optim(beta=initial_beta,
ch=as.matrix(prepped_data$ch),
cap_X=as.matrix(model_fit$cap_X[[i]]),
surv_X=as.matrix(model_fit$surv_X[[i]]),
ints=as.matrix(prepped_data$intervals))
}
endtime<-Sys.time()
optim_speed<-endtime-starttime
ans<-total_escapement(ch=prepped_data$ch,
beta=optim_results$par,
cap_X=model_fit$cap_X[[i]],
surv_X=model_fit$surv_X[[i]],
ints=as.matrix(prepped_data$intervals),
subsampling_weeks=prepped_data$subsampling_weeks,
observed_per_week=prepped_data$observed_per_week,
tagged_per_week=prepped_data$tagged_per_week)
est_escapement<-ans$escapement
p_hat<-ans$p_hat
s_hat<-ans$s_hat
ch=prepped_data$ch
beta=optim_results$par
cap_X=model_fit$cap_X[[i]]
surv_X=model_fit$surv_X[[i]]
ints=as.matrix(prepped_data$intervals)
######################################################
#calculate model fit statistics (aic, qaic, qaicc)
######################################################
loglik<-optim_results$value
ic<-prepped_data$ch
nan=nrow(ic)
ns=ncol(ic)
fit_results <- cjs_fit_simple(ch, beta, cap_X, surv_X, ints)
c_hat<-fit_results
#df<-fit_results$idfgt
n_params<-length(beta)
AIC=2*loglik+2*n_params
AICc=AIC+((2*n_params)*(n_params+1))/(nan-n_params-1)
QAIC=((2*loglik)/c_hat)+(2*n_params)
QAICC=QAIC+(2*n_params*(n_params+1))/(nan-n_params-1)
c_hat
QAICC
##########################################
#CJS_run
##########################################
CJS_run<-function(){
#ask for data if needed, check if already exists
refreshData <- TRUE
if (exists("prepped_data")){
new.data <- select.list(c("Keep the 'CURRENT' data file sets",
"Load 'NEW' data file sets"),
multiple = FALSE,
graphics = FALSE,
title = "Which Data Files to Use?")
refreshData <- substr(new.data,1,4)=="Load"
}
#run CJS_data_prep()
if(refreshData==TRUE){
prepped_data<-CJS_data_prep()
assign("prepped_data", prepped_data, pos=.GlobalEnv) # save for next round, possibly
}
#select one or more model
models = c(	"constant capture and survival rates",
"constant capture rate and survival related the sex",
"constant capture rate and survival related the length",
"capture related to sex and constant survival rate",
"capture related to length and constant survival rate",
"capture related to sex and survival related to length",
"capture related to length and survival related to sex",
"capture related to sex and survival related to sex",
"capture related to length and survival related to length")
model_fit<-CJS_model_select(prepped_data$covars_ask,
prepped_data$sex_matrix,
prepped_data$lengths_matrix,
prepped_data$ch)
n_boot<-get_bootstrap_iterations()
c_hat = 1
initial_beta=numeric(4)
model_results=data.frame()
for(i in model_fit$models_ran){
#est_escapement = NaN when i=6 (cap~sex, surv~length)
#this seems to be because the fill_prob_matrices is producing all 1s for length covariates?
#this is produced in the pro_capsur function
#seems to be because of exp(cap_beta[1]*1+cap_beta[2]*cap_X[i,j])
#the beta parameters are way high when using length
#this only seems to happen for this model variant for this data?
#note it doesn't happen with Trent's application
#skip for now (3/26/2025)
print(paste("beginning model:",i," (",
models[i],")",sep=""))
model_num=i
starttime<-Sys.time()
{gc()
optim_results<-cpp_optim(beta=initial_beta,
ch=as.matrix(prepped_data$ch),
cap_X=as.matrix(model_fit$cap_X[[i]]),
surv_X=as.matrix(model_fit$surv_X[[i]]),
ints=as.matrix(prepped_data$intervals))
}
endtime<-Sys.time()
optim_speed<-endtime-starttime
ans<-total_escapement(ch=prepped_data$ch,
beta=optim_results$par,
cap_X=model_fit$cap_X[[i]],
surv_X=model_fit$surv_X[[i]],
ints=as.matrix(prepped_data$intervals),
subsampling_weeks=prepped_data$subsampling_weeks,
observed_per_week=prepped_data$observed_per_week,
tagged_per_week=prepped_data$tagged_per_week)
est_escapement<-ans$escapement
p_hat<-ans$p_hat
s_hat<-ans$s_hat
ch=prepped_data$ch
beta=optim_results$par
cap_X=model_fit$cap_X[[i]]
surv_X=model_fit$surv_X[[i]]
ints=as.matrix(prepped_data$intervals)
######################################################
#calculate model fit statistics (aic, qaic, qaicc)
######################################################
loglik<-optim_results$value
ic<-prepped_data$ch
nan=nrow(ic)
ns=ncol(ic)
fit_results <- cjs_fit_simple(ch, beta, cap_X, surv_X, ints)
c_hat<-fit_results
#df<-fit_results$idfgt
n_params<-length(beta)
AIC=2*loglik+2*n_params
AICc=AIC+((2*n_params)*(n_params+1))/(nan-n_params-1)
QAIC=((2*loglik)/c_hat)+(2*n_params)
QAICC=QAIC+(2*n_params*(n_params+1))/(nan-n_params-1)
if(n_boot!=0){
boot_start<-Sys.time()
boot_results<-CJS_bootstrap(iterations=n_boot,
ch=ic,
cap_X=model_fit$cap_X[[i]],
surv_X=model_fit$surv_X[[i]],
ints=prepped_data$intervals,
subsampling_weeks=prepped_data$subsampling_weeks,
observed_per_week=prepped_data$observed_per_week,
tagged_per_week=prepped_data$tagged_per_week)
boot_end<-Sys.time()
boot_speed=boot_end-boot_start
#confidence intervals
conf.level = 95
alpha = 1 - conf.level/100
lower = alpha/2
upper = 1 - alpha/2
mid=.5
ci<-boot_results%>%
summarise(lower_ci=ceiling(quantile(escapement,probs = c(lower),na.rm=T)),
mid_ci=ceiling(quantile(escapement,probs = c(mid),na.rm=T)),
upper_ci=ceiling(quantile(escapement,probs = c(upper),na.rm=T)))
p<-ggplot(boot_results,aes(x=escapement))+
geom_histogram(color = "#000000", fill = "#0099F8")+
geom_segment(data=ci,aes(x=lower_ci,xend=lower_ci,y=0,yend=Inf),
linewidth=1,linetype='dashed')+
geom_segment(data=ci,aes(x=upper_ci,xend=upper_ci,y=0,yend=Inf),
linewidth=1,linetype='dashed')+
geom_segment(data=ci,aes(x=est_escapement,
xend=est_escapement,y=0,yend=Inf),
linewidth=1,linetype='dashed',color='red')+
#scale_x_continuous(breaks = seq(0,10000,500)) +
theme_classic()
ggsave(paste("outputs/plot_model-",i,"_iter-",n_boot,"_",Sys.Date(),".png",
sep=""),p,scale=4)
}
d<-data.frame(est_escapement,
optim_speed,
cap_beta1=optim_results$par[1],
cap_beta2=optim_results$par[2],
surv_beta1=optim_results$par[3],
surv_beta2=optim_results$par[4],
loglik,
model=models[i],
AIC,
AICc,
QAIC,
QAICC,
c_hat
)
if(n_boot!=0){
d<-data.frame(d,lower_ci=ci$lower_ci,
upper_ci=ci$upper_ci,
n_boot,
boot_speed)
}
model_results<-model_results%>%
rbind(d)
}
model_results <- model_results %>%
mutate(
delta_AIC = AIC - min(AIC),
delta_AICc = AICc - min(AICc),
AIC_weight = exp(-0.5 * delta_AIC) / sum(exp(-0.5 * delta_AIC)),
AICc_weight = exp(-0.5 * delta_AICc) / sum(exp(-0.5 * delta_AICc))
) %>%
arrange(AIC)  # Sort by best model first
write.csv(model_results,paste("outputs/CJS_outputs-",
Sys.Date(),
".csv",
sep=""),
row.names = F)
return(model_results)
}
results<-CJS_run()
View(results)
##########################################
#model selection for shiny app
##########################################
#wrapper function for
CJS_model_select_app <- function(covars_used, sex_matrix, lengths_matrix, ch, selected_models) {
models = c(
"constant capture and survival rates",
"constant capture rate and survival related to sex",
"constant capture rate and survival related to length",
"capture related to sex and constant survival rate",
"capture related to length and constant survival rate",
"capture related to sex and survival related to length",
"capture related to length and survival related to sex",
"capture related to sex and survival related to sex",
"capture related to length and survival related to length"
)
if (covars_used) {
if (is.null(selected_models)) {
# Default to first model if none selected but covariates are available
models.to.fit <- 1
} else {
models.to.fit <- which(models %in% selected_models)
}
} else {
# If no covariates, only allow the first model
models.to.fit <- 1
}
model_covars = list(cap_X = NULL, surv_X = NULL)
for (m in models.to.fit) {
if (m == 1) {
model_covars$cap_X[[m]] = matrix(1, nrow = nrow(ch), ncol = ncol(ch))
model_covars$surv_X[[m]] = matrix(1, nrow = nrow(ch), ncol = ncol(ch))
}
if (m == 2) {
model_covars$cap_X[[m]] = matrix(1, nrow = nrow(ch), ncol = ncol(ch))
model_covars$surv_X[[m]] = sex_matrix
}
if (m == 3) {
model_covars$cap_X[[m]] = matrix(1, nrow = nrow(ch), ncol = ncol(ch))
model_covars$surv_X[[m]] = lengths_matrix
}
if (m == 4) {
model_covars$cap_X[[m]] = sex_matrix
model_covars$surv_X[[m]] = matrix(1, nrow = nrow(ch), ncol = ncol(ch))
}
if (m == 5) {
model_covars$cap_X[[m]] = lengths_matrix
model_covars$surv_X[[m]] = matrix(1, nrow = nrow(ch), ncol = ncol(ch))
}
if (m == 6) {
model_covars$cap_X[[m]] = sex_matrix
model_covars$surv_X[[m]] = lengths_matrix
}
if (m == 7) {
model_covars$cap_X[[m]] = lengths_matrix
model_covars$surv_X[[m]] = sex_matrix
}
if (m == 8) {
model_covars$cap_X[[m]] = sex_matrix
model_covars$surv_X[[m]] = sex_matrix
}
if (m == 9) {
model_covars$cap_X[[m]] = lengths_matrix
model_covars$surv_X[[m]] = lengths_matrix
}
}
return(list(
'models_ran' = models.to.fit,
'ch' = ch,
'cap_X' = model_covars$cap_X,
'surv_X' = model_covars$surv_X
))
}
cjs_fit <- function(ch, beta, cap_X, surv_X, ints, min_expected = 1) {
# Calculate fitted probabilities from your model
prob_matrices <- fill_prob_matrices(ch, beta, cap_X, surv_X, ints)
p_hat <- prob_matrices$p_hat
s_hat <- prob_matrices$s_hat
nan <- nrow(ch)
ns <- ncol(ch)
# ------------------------------------------------------------------
# TEST 2: Compare observed vs expected m-array
# ------------------------------------------------------------------
# Create OBSERVED m-array
m_obs <- matrix(0, nrow = ns, ncol = ns)
releases <- numeric(ns)
for (i in 1:nan) {
for (j in 1:(ns-1)) {
if (ch[i, j] >= 1) {
releases[j] <- releases[j] + 1
found_next <- FALSE
for (k in (j+1):ns) {
if (ch[i, k] >= 1) {
m_obs[j, k] <- m_obs[j, k] + 1
found_next <- TRUE
break
}
}
}
}
}
# Create EXPECTED m-array from model predictions
m_exp <- matrix(0, nrow = ns, ncol = ns)
for (j in 1:(ns-1)) {
if (releases[j] > 0) {
for (i in 1:nan) {
if (ch[i, j] >= 1) {
# Probability of surviving from j to k and being captured at k
# but not captured between j and k
for (k in (j+1):ns) {
surv_prob <- 1
for (t in j:(k-1)) {
surv_prob <- surv_prob * s_hat[i, t]
}
cap_prob <- p_hat[i, k]
not_cap_prob <- 1
for (t in (j+1):(k-1)) {
not_cap_prob <- not_cap_prob * (1 - p_hat[i, t])
}
m_exp[j, k] <- m_exp[j, k] + surv_prob * cap_prob * not_cap_prob
}
}
}
}
}
# Calculate Test 2 chi-square
chi_sq_2 <- 0
df_2 <- 0
if (ns >= 4) {
for (j in 2:(ns-2)) {
# Compare newly marked vs previously marked
prev_marked_obs <- sum(m_obs[1:(j-1), (j+1):ns])
new_marked_obs <- sum(m_obs[j, (j+1):ns])
prev_marked_exp <- sum(m_exp[1:(j-1), (j+1):ns])
new_marked_exp <- sum(m_exp[j, (j+1):ns])
# Skip if expected counts too small
if (prev_marked_exp < min_expected || new_marked_exp < min_expected) {
next
}
# Chi-square contribution (simplified - actual would be more detailed)
chi_sq_2 <- chi_sq_2 + (prev_marked_obs - prev_marked_exp)^2 / prev_marked_exp
chi_sq_2 <- chi_sq_2 + (new_marked_obs - new_marked_exp)^2 / new_marked_exp
df_2 <- df_2 + 1
}
}
# ------------------------------------------------------------------
# TEST 3: Compare observed vs expected capture histories
# ------------------------------------------------------------------
chi_sq_3 <- 0
df_3 <- 0
for (j in 2:(ns-1)) {
# Create 2x2 table: captured at j vs captured at j+1
obs_table <- matrix(0, nrow = 2, ncol = 2)
exp_table <- matrix(0, nrow = 2, ncol = 2)
for (i in 1:nan) {
# Only animals alive at j
alive_at_j <- FALSE
for (t in j:ns) {
if (ch[i, t] >= 1) {
alive_at_j <- TRUE
break
}
}
if (alive_at_j) {
captured_j <- as.numeric(ch[i, j] >= 1)
captured_j1 <- as.numeric(ch[i, j+1] >= 1)
obs_table[captured_j + 1, captured_j1 + 1] <-
obs_table[captured_j + 1, captured_j1 + 1] + 1
# Expected probability
if (captured_j == 1) {
# Animal captured at j
exp_prob <- s_hat[i, j] * p_hat[i, j+1]
} else {
# Animal not captured at j but could be captured at j+1
exp_prob <- s_hat[i, j] * p_hat[i, j+1] * (1 - p_hat[i, j])
}
# Simplified expected counts
exp_table[captured_j + 1, captured_j1 + 1] <-
exp_table[captured_j + 1, captured_j1 + 1] + exp_prob
}
}
# Calculate chi-square if expected counts sufficient
if (sum(exp_table) > min_expected * 4) {
for (r in 1:2) {
for (c in 1:2) {
if (exp_table[r, c] > min_expected) {
chi_sq_3 <- chi_sq_3 + (obs_table[r, c] - exp_table[r, c])^2 / exp_table[r, c]
}
}
}
df_3 <- df_3 + 1
}
}
# ------------------------------------------------------------------
# Calculate c-hat
# ------------------------------------------------------------------
total_chi_sq <- chi_sq_2 + chi_sq_3
total_df <- df_2 + df_3
if (total_df > 0) {
c_hat <- total_chi_sq / total_df
c_hat <- max(1.0, c_hat)  # c-hat should be at least 1
} else {
c_hat <- 1.0
}
return(list(
vif = c_hat,
chigt = total_chi_sq,
idfgt = total_df,
diagnostic = list(
test2_chi_sq = chi_sq_2,
test2_df = df_2,
test3_chi_sq = chi_sq_3,
test3_df = df_3
)
))
}
# ------------------------------------------------------------------
# Helper function for TEST 2
# ------------------------------------------------------------------
calculate_test2 <- function(ns, m, releases, min_expected, use_chat_rot, chat_rot) {
chi_sq <- 0
df <- 0
# For each release occasion j from 2 to ns-2
for (j in 2:(ns-2)) {
# Create contingency table for release occasion j
# Rows: Previously marked (releases before j) vs Newly marked (releases at j)
# Columns: Recaptured at occasions j+1 to ns
# Previously marked: sum of releases before j that were recaptured
prev_marked <- numeric(ns - j)
new_marked <- numeric(ns - j)
for (k in (j+1):ns) {
# Previously marked: animals released before j and recaptured at k
prev_marked[k-j] <- sum(m[1:(j-1), k])
# Newly marked: animals released at j and recaptured at k
new_marked[k-j] <- m[j, k]
}
# Row totals
prev_total <- sum(prev_marked)
new_total <- sum(new_marked)
col_totals <- prev_marked + new_marked
# Column totals (total recaptures at each occasion)
total_animals <- prev_total + new_total
# Skip if insufficient data
if (total_animals < min_expected) {
next
}
# Calculate expected values and chi-square
for (k in 1:length(prev_marked)) {
# Expected counts under independence
exp_prev <- prev_total * col_totals[k] / total_animals
exp_new <- new_total * col_totals[k] / total_animals
# Skip if expected count too small
if (exp_prev < min_expected || exp_new < min_expected) {
next
}
# Chi-square contribution
chi_sq <- chi_sq + ((prev_marked[k] - exp_prev)^2 / exp_prev)
chi_sq <- chi_sq + ((new_marked[k] - exp_new)^2 / exp_new)
df <- df + 1
}
# Adjust degrees of freedom (for each column we lose 1 df)
df <- df - 1  # Because column totals sum to row totals
}
return(list(chi_sq = chi_sq, df = max(0, df)))
}
#quick esc_est testing
#created: 12/23/2025
#last update: 12/23/2025
rm( list = ls()) #clear env
library(tidyverse)
library(escapeMR)
library(Rcpp)
source("scripts/CVCS_functions.R")
results<-CJS_run()
View(results)
#quick esc_est testing
#created: 12/23/2025
#last update: 12/23/2025
rm( list = ls()) #clear env
library(tidyverse)
library(escapeMR)
library(Rcpp)
source("scripts/CVCS_functions.R")
results<-CJS_run()
View(results)
#quick esc_est testing
#created: 12/23/2025
#last update: 12/23/2025
rm( list = ls()) #clear env
library(tidyverse)
library(escapeMR)
library(Rcpp)
source("scripts/CVCS_functions.R")
results<-CJS_run()
692-164
164/8
46/18
18/46
18/45
45-18
24-17
40-16
27/3
